<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DeepParadise</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
    }
    canvas { border: 1px solid #ccc; background: transparent; }
  </style>
</head>
<body>
  <canvas id="Canvas" width="600" height="600" ></canvas>
  <canvas id="CanvasUpscale" width="10" height="10"></canvas>
  <p1>Zoom: </p1>
  <input type="range" id="slider" min="1" max="900" value="200">
  <p1>Speed: </p1>
  <input type="range" id="slider2" min="-5" max="5" value="0">
  <p1>IgnoreZ</p1>
  <input type="checkbox" id="IgnoreZToDraw">
  <p1>Chance Pespective</p1>
  <input type="checkbox" id="PS1GPHC">
  <input type="checkbox" id="gravity">
  <img src="https://wallpaperaccess.com/full/83995.jpg" id="image" hidden>
  <img src="235672.png" id="image2" hidden>
  <script>
	let slider = document.getElementById("slider");
	let slider2 = document.getElementById("slider2");
	let slider3 = document.getElementById("slider3");
    	const canvas = document.getElementById("Canvas");
	const canvasUpscale = document.getElementById("CanvasUpscale");
    	const ctx = canvas.getContext("2d");
	const ctxUpscale = canvasUpscale.getContext("2d")
	let cube = [
  	{ x: -1, y: -1, z: -1 },
  	{ x:  1, y: -1, z: -1 },
  	{ x:  1, y:  1, z: -1 },
  	{ x: -1, y:  1, z: -1 },
  	{ x: -1, y: -1, z:  1 },
  	{ x:  1, y: -1, z:  1 },
  	{ x:  1, y:  1, z:  1 },
  	{ x: -1, y:  1, z:  1 }
	];
	let triangle = [
	{x: -1, y: 1, z: -1},
	{x: 1, y: 1, z: -1},
	{x: 1, y: 1, z: 1},
	{x: -1, y: 1, z: 1},
	{x: 0, y: -1, z: 0}
	];
	let plane = [
	{x: -2, y: 1, z: 2},
	{x: 2, y: 1, z: 2},
	{x: 2, y: 1, z: -2},
	{x: -2, y: 1, z: -2},
	];

	let keys = {};

	document.addEventListener("keydown", e => keys[e.key] = true)
	document.addEventListener("keyup", e => keys[e.key] = false)

	ctxUpscale.imageSmoothingEnabled = false;
	ctx.imageSmoothingEnabled = false;

	let camera = {
		x: 0,
		y: 0,
		z: 0,
		camera_angle_x: 90,
		camera_angle_y: 0,
		camera_angle_z: 0
	}

	let PS1GPHC = document.getElementById("PS1GPHC");
	let ignoreZ = document.getElementById("IgnoreZToDraw");
	let trianglecheck = document.getElementById("TriangleBox");
	let transitionZ = 10;
	let negativeDepth = 0;
	let nd = 0;

	let tempo = 0;

	function rotateYZ(point, angle) {
  		const cos = Math.cos(angle);
  		const sin = Math.sin(angle);
		/*let p4 = multiMatrix(p1, p2, p3)*/
		return {
			x: point.x,
			y: point.y*cos-point.z*sin,
			z: point.y*sin+point.z*cos
		};
	};
	function rotateXZ(point, angle){
		const cos = Math.cos(angle);
		const sin = Math.sin(angle);

		return {
			x: point.x*cos-point.z*sin,
			y: point.y,
			z: point.x*sin+point.z*cos
		};
	};
	function rotateXY(point, angle){
		const cos = Math.cos(angle);
		const sin = Math.sin(angle);
		
		return {
			x: point.x*cos-point.y*sin,
			y: point.x*sin+point.y*cos,
			z: point.z
		};
	};

	function translateXYZ(point, pos_x, pos_y, pos_z){
		return {
			x: point.x+pos_x,
			y: point.y+pos_y,
			z: point.z+pos_z
		};
};

	function cameraTranslate(point){
		return {
			x: point.x+camera.x,
			y: point.y+camera.y,
			z: point.z+camera.z
		};
	};

	function cameraRotateXZ(point, angle){
		const cos = Math.cos(-angle)
		const sin = Math.sin(-angle)

		return {
			x: point.x*cos-point.z*sin,
			y: point.y,
			z: point.x*sin+point.z*cos
		};
	};

	function cameraRotateYZ(point, angle){
		const cos = Math.cos(-angle)
		const sin = Math.sin(-angle)
		
		return {
			x: point.x,
			y: point.y*cos-point.z*sin,
			z: point.y*sin+point.z*cos
		};
	};

	function cameraRotateXY(point, angle){
		const cos = Math.cos(-angle)
		const sin = Math.sin(-angle)

		return {
			x: point.x*cos-point.y*sin,
			y: point.x*sin+point.y*cos,
			z: point.z
		};
	};

	function getNormal(p1, p2, p3){
		const u = {
			x: p2.x - p1.x,
			y: p2.y - p1.y,
			z: p2.z - p1.z
		};
		const v = {
			x: p3.x - p1.x,
			y: p3.y - p1.y,
			z: p3.z - p1.z
		};
		return {
			x: u.y*v.z - u.z*v.y,
			y: u.z*v.x - u.x*v.z,
			z: u.x*v.y - u.y*v.x
		};
	};

	function dot(a, b){
		return a.x*b.x + a.y*b.y + a.z*b.z
	}

	function getViewDir(cam, ve1, ve2, ve3){
		const faceCenter = {
			x: (ve1.x + ve2.x + ve3.x)/3,
			y: (ve1.y + ve2.y + ve3.y)/3,
			z: (ve1.z + ve2.z + ve3.z)/3
		};

  		return faceCenter;
	};
	
	function normalize(v){
  		const len = Math.sqrt(v.x*v.x + v.y*v.y + v.z*v.z);
  		return { x: v.x/len, y: v.y/len, z: v.z/len };
	};

	function to15bit(r,g,b){
  		const R = (r>>3)&0x1F, G=(g>>3)&0x1F, B=(b>>3)&0x1F;
  		return { r: (R<<3), g: (G<<3), b: (B<<3) };
	};


	function project(point, angle){
  		const scale = slider.value;
  		const z = point.z;
		if (ignoreZ.checked == false && z >= 40){
			return 0
		}
		if (z <= negativeDepth){
			return 0
		};
		if (PS1GPHC.checked == true){
			transitionZ = 10;
			nd = -20;
			return {
				x: Math.floor((canvas.width / 2 + (point.x * scale))/2)*2,
    				y: Math.floor((canvas.height / 2 + (point.y * scale))/2)*2
			}
		}
		nd = 0;
		transitionZ = 200;
  		return {
  			x: Math.floor((canvas.width / 2 + (point.x * scale)/z)/2)*2,
    			y: Math.floor((canvas.height / 2 + (point.y * scale)/z)/2)*2
  		};
	};

	function projectPlane(point, angle){
		const scale = slider.value;
  		const z = point.z;
		if (ignoreZ.checked == false && z >= 40){
			return 0
		}
		if (z <= 0 && z >= -4){
			return {
				x: Math.floor((canvas.width / 2 + (point.x * scale))/2)*2,
    				y: Math.floor((canvas.height / 2 + (point.y * scale))/2)*2
			};
		};
		if (z <= negativeDepth){
			return 0
		};
		if (PS1GPHC.checked == true){
			transitionZ = 10;
			nd = -20;
			return {
				x: Math.floor((canvas.width / 2 + (point.x * scale))/2)*2,
    				y: Math.floor((canvas.height / 2 + (point.y * scale))/2)*2
			}
		}
		nd = 0;
		transitionZ = 200;
  		return {
  			x: Math.floor((canvas.width / 2 + (point.x * scale)/z)/2)*2,
    			y: Math.floor((canvas.height / 2 + (point.y * scale)/z)/2)*2
  		};
	};

	function drawCube(mesh, pos_x, pos_y, pos_z, angle_x, angle_y, angle_z, faces, colortable) {
		const translated = mesh.map(p => translateXYZ(p, pos_x, pos_y, pos_z));
		if (getDistance(translated[0].x, translated[1].y, translated[2].z, -camera.x, -camera.y, -camera.z) > 44){
			return 0
		};
  		const rotatedXZ = translated.map(p => rotateXZ(p, angle_x));
		const rotatedYZ = rotatedXZ.map(p => rotateYZ(p, angle_y))
		const rotatedXY = rotatedYZ.map(p => rotateXY(p, angle_z))
		const cameraTranslated = rotatedXY.map(p => cameraTranslate(p, pos_x, pos_y, pos_z))
		const cameraRotatedXZ = cameraTranslated.map(p => cameraRotateXZ(p, camera.camera_angle_x))
		const cameraRotatedYZ = cameraRotatedXZ.map(p => cameraRotateYZ(p, camera.camera_angle_y))
		const cameraRotatedXY = cameraRotatedYZ.map(p => cameraRotateXY(p, camera.camera_angle_z))
  		const projected = cameraRotatedXY.map(project);

  		ctx.beginPath();
  		faces.forEach(([a, b, c]) => {
			const N = normalize(getNormal(cameraRotatedXY[a], cameraRotatedXY[b], cameraRotatedXY[c]))
			const cameraDir = normalize(getViewDir(camera, cameraRotatedXY[a], cameraRotatedXY[b], cameraRotatedXY[c]))
			if (dot(N, cameraDir) > 0) {
				/*ctx.beginPath()
				ctx.globalAlpha = 1
				ctx.strokeStyle = "rgb(255, 0, 255)"
				ctx.moveTo(projected[a].x, projected[a].y);
   				ctx.lineTo(projected[b].x, projected[b].y);
				ctx.lineTo(projected[c].x, projected[c].y);
				ctx.stroke()*/
				ctx.beginPath();
				/*ctx.globalAlpha = 0.5*/
				ctx.strokeStyle = "rgb(0, 0, 0)";
				ctx.fillStyle = "rgb(0, 0, 0)"
				if (colortable != null) {
					if (colortable[a] != null && colortable[b] != null && colortable[c] != null) {
						let intersity = Math.max(0, dot(N, cameraDir))
						let distance = 1-getDistance(translated[a].x, translated[a].y, translated[a].z, -camera.x, camera.y, -camera.z)/30
						let colorr = Math.max(0, Math.floor((colortable[a] * (intersity * distance))/4)*4)
						let colorg = Math.max(0, Math.floor((colortable[b] * (intersity * distance))/4)*4)
						let colorb = Math.max(0, Math.floor((colortable[c] * (intersity * distance))/4)*4)
						colorReduced = to15bit(colorr, colorg, colorb);
						ctx.fillStyle = `rgb(${colorReduced.r}, ${colorReduced.g}, ${colorReduced.b})`;
					};
				};
   				ctx.moveTo(projected[a].x, projected[a].y);
   				ctx.lineTo(projected[b].x, projected[b].y);	
				ctx.lineTo(projected[c].x, projected[c].y);
				ctx.lineTo(projected[a].x, projected[a].y);
				ctx.fill();
				/*ctx.stroke();*/
			};
  		});
	};
	
	function getDistance(x1, y1, z1, x2, y2, z2){
		const dx = x2 - x1;
		const dy = y2 - y1;
		const dz = z2 - z1;

		return Math.sqrt((dx*dx)+(dy*dy)+(dz*dz))
	}
	
	function drawMesh(mesh, pos_x, pos_y, pos_z, angle_x, angle_y, angle_z, faces, colortable) {
		const translated = mesh.map(p => translateXYZ(p, pos_x, pos_y, pos_z));
		/*const tN = getNormal(translated[0], translated[1], translated[2]);
		const tcameraDir = getViewDir(camera);*/
  		const rotatedXZ = translated.map(p => rotateXZ(p, angle_x));
		const rotatedYZ = rotatedXZ.map(p => rotateYZ(p, angle_y))
		const rotatedXY = rotatedYZ.map(p => rotateXY(p, angle_z))
		const cameraTranslated = rotatedXY.map(p => cameraTranslate(p, pos_x, pos_y, pos_z))
		const cameraRotatedXZ = cameraTranslated.map(p => cameraRotateXZ(p, camera.camera_angle_x))
		const cameraRotatedYZ = cameraRotatedXZ.map(p => cameraRotateYZ(p, camera.camera_angle_y))
		const cameraRotatedXY = cameraRotatedYZ.map(p => cameraRotateXY(p, camera.camera_angle_z))
  		const projected = cameraRotatedXY.map(projectPlane);

  		ctx.beginPath();
  		faces.forEach(([a, b, c]) => {
			const N = getNormal(rotatedXY[a], rotatedXY[b], rotatedXY[c]);
			const cameraDir = getViewDir(camera, rotatedXY[a], rotatedXY[b], rotatedXY[c]);
			/*ctx.beginPath()
			ctx.globalAlpha = 1
			ctx.strokeStyle = "rgb(255, 0, 255)"
			ctx.moveTo(projected[a].x, projected[a].y);
   			ctx.lineTo(projected[b].x, projected[b].y);
			ctx.lineTo(projected[c].x, projected[c].y);
			ctx.stroke()*/
			ctx.beginPath();
			/*ctx.globalAlpha = 0.5*/
			ctx.strokeStyle = "rgb(0, 0, 0)";
			ctx.fillStyle = "rgb(0, 0, 0)"
			if (colortable != null) {
				if (colortable[a] != null && colortable[b] != null && colortable[c] != null) {
					/*let intersity = 1;*/
					let intersity = 1-Math.max(0, getDistance(translated[a].x, translated[a].y, translated[a].z, -camera.x, camera.y, -camera.z))/40
					let colorr = Math.max(0, Math.floor((colortable[a] * intersity)/4)*4)
					let colorg = Math.max(0, Math.floor((colortable[b] * intersity)/4)*4)
					let colorb = Math.max(0, Math.floor((colortable[c] * intersity)/4)*4)
					colorReduced = to15bit(colorr, colorg, colorb);
					ctx.fillStyle = `rgb(${colorReduced.r}, ${colorReduced.g}, ${colorReduced.b})`;
				};
			};
   			ctx.moveTo(projected[a].x, projected[a].y);
   			ctx.lineTo(projected[b].x, projected[b].y);	
			ctx.lineTo(projected[c].x, projected[c].y);
			ctx.lineTo(projected[a].x, projected[a].y);
			ctx.fill();
			/*ctx.stroke();*/
  		});
	};

	function createPlane(int){
		let mn1 = 0;
		let mn2 = 0;
		for (i=0; i < int; i++){
			faces = [
  		  		[0,1,2],[2,3,0],
  			];
			if (getDistance(mn1, 0, mn2, camera.x, camera.y, camera.z) > 44){
				
			}else{
				drawMesh(plane, -mn1, 0, -mn2, 0, 0, 0, faces, [0, 0, 128, 155, 0])
			};
			if (mn1 == 256) {
				mn1 = 0;
				mn2 += 4;
			}else{
				mn1 += 4;
			};
		};
	};
	
	
	function createHouse(x, y, z){
		faces = [
  		  	[0,1,2],[2,3,0],
			[7,6,5],[5,4,7],
			[4,5,1],[1,0,4],[3,2,6],[6,7,3],
			[0,3,7],[7,4,0],[5,6,2],[2,1,5]
  		];
		drawCube(cube, x, y, z, 0, 0, 0, faces, [255, 0, 0, 0, 255, 0]);
		drawCube(cube, x, y, z+2, 0, 0, 0, faces);
		drawCube(cube, x, y, z+4, 0, 0, 0, faces);
		drawCube(cube, x, y, z+6, 0, 0, 0, faces);
		drawCube(cube, x, y, z+8, 0, 0, 0, faces);
		drawCube(cube, x, y, z+10, 0, 0, 0, faces);
		drawCube(cube, x, y, z+12, 0, 0, 0, faces);
		drawCube(cube, x+2, y, z+12, 0, 0, 0, faces);
		drawCube(cube, x+4, y, z+12, 0, 0, 0, faces);
		drawCube(cube, x+6, y, z+12, 0, 0, 0, faces);
		drawCube(cube, x+8, y, z+12, 0, 0, 0, faces);
		drawCube(cube, x+10, y, z+12, 0, 0, 0, faces);
		drawCube(cube, x+12, y, z+12, 0, 0, 0, faces);
		drawCube(cube, x+14, y, z+12, 0, 0, 0, faces);
		drawCube(cube, x+16, y, z+12, 0, 0, 0, faces);
		drawCube(cube, x+18, y, z+12, 0, 0, 0, faces);
		drawCube(cube, x+20, y, z+12, 0, 0, 0, faces);
		drawCube(cube, x+22, y, z+12, 0, 0, 0, faces);
		drawCube(cube, x+22, y, z+10, 0, 0, 0, faces);
		drawCube(cube, x+22, y, z+8, 0, 0, 0, faces);
		drawCube(cube, x+22, y, z+6, 0, 0, 0, faces);
		drawCube(cube, x+22, y, z+4, 0, 0, 0, faces);
		drawCube(cube, x+22, y, z+2, 0, 0, 0, faces);
		drawCube(cube, x+22, y, z, 0, 0, 0, faces);
		drawCube(cube, x+22, y, z-2, 0, 0, 0, faces);
		drawCube(cube, x+22, y, z-4, 0, 0, 0, faces);
		drawCube(cube, x+22, y, z-6, 0, 0, 0, faces);
		drawCube(cube, x+22, y, z-8, 0, 0, 0, faces);
		drawCube(cube, x+22, y, z-10, 0, 0, 0, faces);
		drawCube(cube, x+22, y, z-12, 0, 0, 0, faces);
		drawCube(cube, x, y-2, z, 0, 0, 0, faces);
		drawCube(cube, x, y-2, z+2, 0, 0, 0, faces);
		drawCube(cube, x, y-2, z+4, 0, 0, 0, faces);
		drawCube(cube, x, y-2, z+6, 0, 0, 0, faces);
		drawCube(cube, x, y-2, z+8, 0, 0, 0, faces);
		drawCube(cube, x, y-2, z+10, 0, 0, 0, faces);
		drawCube(cube, x, y-2, z+12, 0, 0, 0, faces);
		drawCube(cube, x+2, y-2, z+12, 0, 0, 0, faces);
		drawCube(cube, x+4, y-2, z+12, 0, 0, 0, faces);
		drawCube(cube, x+6, y-2, z+12, 0, 0, 0, faces);
		drawCube(cube, x+8, y-2, z+12, 0, 0, 0, faces);
		drawCube(cube, x+10, y-2, z+12, 0, 0, 0, faces);
		drawCube(cube, x+12, y-2, z+12, 0, 0, 0, faces);
		drawCube(cube, x+14, y-2, z+12, 0, 0, 0, faces);
		drawCube(cube, x+16, y-2, z+12, 0, 0, 0, faces);
		drawCube(cube, x+18, y-2, z+12, 0, 0, 0, faces);
		drawCube(cube, x+20, y-2, z+12, 0, 0, 0, faces);
		drawCube(cube, x+22, y-2, z+12, 0, 0, 0, faces);
		drawCube(cube, x+22, y-2, z+10, 0, 0, 0, faces);
		drawCube(cube, x+22, y-2, z+8, 0, 0, 0, faces);
		drawCube(cube, x+22, y-2, z+6, 0, 0, 0, faces);
		drawCube(cube, x+22, y-2, z+4, 0, 0, 0, faces);
		drawCube(cube, x+22, y-2, z+2, 0, 0, 0, faces);
		drawCube(cube, x+22, y-2, z, 0, 0, 0, faces);
		drawCube(cube, x+22, y-2, z-2, 0, 0, 0, faces);
		drawCube(cube, x+22, y-2, z-4, 0, 0, 0, faces);
		drawCube(cube, x+22, y-2, z-6, 0, 0, 0, faces);
		drawCube(cube, x+22, y-2, z-8, 0, 0, 0, faces);
		drawCube(cube, x+22, y-2, z-10, 0, 0, 0, faces);
		drawCube(cube, x+22, y-2, z-12, 0, 0, 0, faces);
	};


	canvas.addEventListener('mousemove', function(event) {
		const rect = canvas.getBoundingClientRect()
		
		const mouseX = event.clientX - rect.left
		const mouseY = event.clientY - rect.top
		camera.camera_angle_x = (1.5-mouseX*3.14/180)
		camera.camera_angle_y = (1.5-mouseY*3.14/180)
	}, false)

	let angle = 0;
	let grav = 0;
	function animate() {
		if (keys["ArrowUp"]) camera.z += 0.5;
		if (keys["ArrowDown"]) camera.z -= 0.5;
		if (keys["ArrowLeft"]) camera.x -= 0.5;
		if (keys["ArrowRight"]) camera.x += 0.5;
		if (keys[" "]) camera.y += 1;
		if (keys["Control"]) camera.y -= 1;
		if (gravity.checked == true) {
			camera.y = camera.y-grav*10
			grav = grav+0.02
		}else{
			grav = 0
		}
		/*{ x: -1, y: -1, z: -1 },
  		{ x:  1, y: -1, z: -1 },
  		{ x:  1, y:  1, z: -1 },
  		{ x: -1, y:  1, z: -1 },
  		{ x: -1, y: -1, z:  1 },
  		{ x:  1, y: -1, z:  1 },
  		{ x:  1, y:  1, z:  1 },
  		{ x: -1, y:  1, z:  1 }*/
		ctx.clearRect(0, 0, canvas.width, canvas.height);
		ctx.drawImage(document.getElementById("image"), 0, 0, 600, 600)
		createPlane(50000)
		createHouse(-50, 0, -16)
		faces = [
  		  	[0,1,2],[2,3,0],
			[7,6,5],[5,4,7],
			[4,5,1],[1,0,4],[3,2,6],[6,7,3],
			[0,3,7],[7,4,0],[5,6,2],[2,1,5]
  		];
		colortable = [0, 255, 0, 0, 255, 0, 255, 0, 0, 0, 0, 255]
		drawCube(cube, 0, 0, 0, angle, 0, 0, faces, colortable);
		faces = [
  		  	[0,1,2],[2,3,0],
			[7,6,5],[5,4,7],
			[4,5,1],[1,0,4],[3,2,6],[6,7,3],
			[0,3,7],[7,4,0],[5,6,2],[2,1,5]
  		];
		colortable = [0, 255, 0, 0, 255, 0, 255, 0, 0, 0, 0, 255]
		drawCube(cube, -45+Math.sin(angle)*10, 0, -20, 0, 0, 0, faces, colortable);
		/*faces = [
  		  	[0,1,2],[2,3,0],
			[0,4,1],[1,4,2],[2,4,3]
  		];
		drawCube(triangle, 0, -2.4+Math.sin(angle*4)/4, 0, 0, 0, 0, faces);*/
		ctx.drawImage(document.getElementById("image2"), canvas.width/4, canvas.height/2, canvas.width/2, canvas.height/2)
		/*ctxUpscale.clearRect(0,0,canvasUpscale.width, canvasUpscale.height)
		ctxUpscale.drawImage(canvas, 0, 0, canvasUpscale.width, canvasUpscale.height)*/
		/**/
		angle += (0.02+slider2.value/100);
  		/*angle = (1-0.08)*angle+0.08*(slider2.value);*/
		tempo += 0.1
		slider.value = (1-0.1)*slider.value+0.1*transitionZ
		negativeDepth = (1-0.8)*negativeDepth+0.8*nd
		/*console.log((camera.x-0)^2+(camera.y-0)^2+(camera.z-0)^2)*/
  		requestAnimationFrame(animate);
	}
	camera.x = 40;
	camera.y = 3;
	camera.z = 10;
  	animate();

	


  </script>
</body>
</html>
